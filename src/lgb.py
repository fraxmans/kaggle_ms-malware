import numpy as np
import pandas as pd
import lightgbm as lgb

import gc
import pickle
import cPickle
import datetime
import os
import copy
import sys
import time
from multiprocessing import Process, Pool, Manager 

train_path = "data/trainset.csv"
valid_path = "data/validset.csv"
test_path = "data/testset.csv"

params = {'num_leaves': 90,
         'min_data_in_leaf': 90, 
         'objective':'binary',
         'max_depth': -1,
         'learning_rate': 0.1,
         "boosting": "gbdt",
         "feature_fraction": 0.8,
         "bagging_freq": 1,
         "bagging_fraction": 0.8 ,
         "bagging_seed": 11,
         "metric": 'auc',
         "lambda_l1": 0.1,
         "random_state": 133,
         "verbosity": -1}

dtypes = {
    'MachineIdentifier':                                    'object',
    'ProductName':                                          'object',
    'EngineVersion':                                        'object',
    'AppVersion':                                           'object',
    'AvSigVersion':                                         'object',
    'IsBeta':                                               'int8',
    'RtpStateBitfield':                                     'float16',
    'IsSxsPassiveMode':                                     'int8',
    'DefaultBrowsersIdentifier':                            'float16',
    'AVProductStatesIdentifier':                            'float32',
    'AVProductsInstalled':                                  'float16',
    'AVProductsEnabled':                                    'float16',
    'HasTpm':                                               'int8',
    'CountryIdentifier':                                    'int16',
    'CityIdentifier':                                       'float32',
    'OrganizationIdentifier':                               'float16',
    'GeoNameIdentifier':                                    'float16',
    'LocaleEnglishNameIdentifier':                          'int8',
    'Platform':                                             'object',
    'Processor':                                            'object',
    'OsVer':                                                'object',
    'OsBuild':                                              'int16',
    'OsSuite':                                              'int16',
    'OsPlatformSubRelease':                                 'object',
    'OsBuildLab':                                           'object',
    'SkuEdition':                                           'object',
    'IsProtected':                                          'float16',
    'AutoSampleOptIn':                                      'int8',
    'PuaMode':                                              'object',
    'SMode':                                                'float16',
    'IeVerIdentifier':                                      'float16',
    'SmartScreen':                                          'object',
    'Firewall':                                             'float16',
    'UacLuaenable':                                         'float32',
    'Census_MDC2FormFactor':                                'object',
    'Census_DeviceFamily':                                  'object',
    'Census_OEMNameIdentifier':                             'float16',
    'Census_OEMModelIdentifier':                            'float32',
    'Census_ProcessorCoreCount':                            'float16',
    'Census_ProcessorManufacturerIdentifier':               'float16',
    'Census_ProcessorModelIdentifier':                      'float16',
    'Census_ProcessorClass':                                'object',
    'Census_PrimaryDiskTotalCapacity':                      'float32',
    'Census_PrimaryDiskTypeName':                           'object',
    'Census_SystemVolumeTotalCapacity':                     'float32',
    'Census_HasOpticalDiskDrive':                           'int8',
    'Census_TotalPhysicalRAM':                              'float32',
    'Census_ChassisTypeName':                               'object',
    'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',
    'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16',
    'Census_InternalPrimaryDisplayResolutionVertical':      'float16',
    'Census_PowerPlatformRoleName':                         'object',
    'Census_InternalBatteryType':                           'object',
    'Census_InternalBatteryNumberOfCharges':                'float32',
    'Census_OSVersion':                                     'object',
    'Census_OSArchitecture':                                'object',
    'Census_OSBranch':                                      'object',
    'Census_OSBuildNumber':                                 'int16',
    'Census_OSBuildRevision':                               'int32',
    'Census_OSEdition':                                     'object',
    'Census_OSSkuName':                                     'object',
    'Census_OSInstallTypeName':                             'object',
    'Census_OSInstallLanguageIdentifier':                   'float16',
    'Census_OSUILocaleIdentifier':                          'int16',
    'Census_OSWUAutoUpdateOptionsName':                     'object',
    'Census_IsPortableOperatingSystem':                     'int8',
    'Census_GenuineStateName':                              'object',
    'Census_ActivationChannel':                             'object',
    'Census_IsFlightingInternal':                           'float16',
    'Census_IsFlightsDisabled':                             'float16',
    'Census_FlightRing':                                    'object',
    'Census_ThresholdOptIn':                                'float16',
    'Census_FirmwareManufacturerIdentifier':                'float16',
    'Census_FirmwareVersionIdentifier':                     'float32',
    'Census_IsSecureBootEnabled':                           'int8',
    'Census_IsWIMBootEnabled':                              'float16',
    'Census_IsVirtualDevice':                               'float16',
    'Census_IsTouchEnabled':                                'int8',
    'Census_IsPenCapable':                                  'int8',
    'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
    'Wdft_IsGamer':                                         'float16',
    'Wdft_RegionIdentifier':                                'float16',
    'HasDetections':                                        'int8'
}

def reduce_mem_usage(df):
    """ iterate through all the columns of a dataframe and modify the data type to reduce memory usage.        
    """
    start_mem = df.memory_usage().sum() / 1024**2
    print('Memory usage of dataframe is {:.2f} MB'.format(start_mem))

    for col in df.columns:
        col_type = df[col].dtype

        if col_type != object:
            c_min = df[col].min()
            c_max = df[col].max()
        
        if str(col_type)[:3] == 'int':
            if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:
                df[col] = df[col].astype(np.int8)
            elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:
                df[col] = df[col].astype(np.int16)
            elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:
                df[col] = df[col].astype(np.int32)
            elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:
                df[col] = df[col].astype(np.int64)  
        else:
            if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:
                df[col] = df[col].astype(np.float16)
            elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:
                df[col] = df[col].astype(np.float32)
            else:
                df[col] = df[col].astype(np.float64)

    end_mem = df.memory_usage().sum() / 1024**2
    print('Memory usage after optimization is: {:.2f} MB'.format(end_mem))
    print('Decreased by {:.1f}%'.format(100 * (start_mem - end_mem) / start_mem))

    return df

def factorize(args):
    data = args[0]
    col = args[1]
    queue = args[2]

    sys.stderr.write("[%s] Processing %s\n" % (datetime.datetime.now(), col))
    labels, uniques = pd.factorize(data)
    
    queue.put([labels, col])

def merge(args):
    queue = args[0]
    data_dict = {}

    while(1):
        q_args = None
        try:
            q_args = queue.get(timeout=60)
        except:
            df = pd.DataFrame(data_dict)
            queue.put([df])
            return

        labels = q_args[0]
        col = q_args[1]
        data_dict[col] = labels

        sys.stderr.write("[%s] Merge: %s\n" % (datetime.datetime.now(), col))
        
        del labels, col

def col_factorize(data):
    data_obj = data.select_dtypes(include="object")
    sub_args = []
    queue = Manager().Queue()

    for col in data_obj.columns:
        sub_args.append([data[col], col, queue])

    task = []
    for sub_arg in sub_args:
        task.append(Process(target=factorize, args=[sub_arg]))

    for p in task:
        p.start()
    
    for p in task:
        p.join()

    q_args = queue.get(False)
    ret_data_dict = {} 
    while(q_args != None):
        col = q_args[0]
        col_name = q_args[1]

        ret_data_dict[col_name] = col

        try:
            q_args = queue.get(False)
        except:
            break
    
    ret_data = pd.DataFrame(ret_data_dict)

    data_non_obj = data.select_dtypes(exclude="object").copy()
    data_non_obj.index = range(data_non_obj.shape[0])
    ret = pd.concat([data_non_obj, ret_data], axis=1, ignore_index=True)

    return ret 

def load_test_data():
    sys.stderr.write("Loading test data ......\n")
    test_data = pd.read_csv(test_path, dtype=dtypes)
    machine_id = copy.copy(test_data["MachineIdentifier"])

    return test_data, machine_id

def load_valid_data():
    sys.stderr.write("Loading valid data ......\n")

    data = pd.read_csv(valid_path, dtype=dtypes)
    del data["MachineIdentifier"]

    valid_label = data["HasDetections"]
    valid_data = pd.DataFrame(data.drop("HasDetections", axis=1))
    
    return valid_data, valid_label

def load_train_data():
    sys.stderr.write("Loading train data ......\n")

    data = pd.read_csv(train_path, dtype=dtypes)
    del data["MachineIdentifier"]

    train_label = data["HasDetections"]
    train_data = pd.DataFrame(data.drop("HasDetections", axis=1))
    
    return train_data, train_label

def main():
    tr_data, tr_label = load_train_data()
    v_data, v_label = load_valid_data()
    te_data, machine_id = load_test_data()
    offset1 = tr_data.shape[0]
    offset2 = offset1 + v_data.shape[0]

    X = pd.concat([tr_data, v_data, te_data], ignore_index=True, sort=False)
    del tr_data, v_data, te_data
    gc.collect()

    ret = col_factorize(X)
    ret = ret.fillna(-1)
    ret = reduce_mem_usage(ret)

    ret_train_data = ret[:offset1]
    ret_valid_data = ret[offset1:offset2]
    ret_test_data = ret[offset2:]
    del ret
    gc.collect()

    train_data = lgb.Dataset(ret_train_data, label=tr_label, free_raw_data=True)
    ret_train_data = None
    tr_label = None
    gc.collect()

    valid_data = lgb.Dataset(ret_valid_data, label=v_label)
    ret_valid_data = None
    v_label = None
    gc.collect()

    sys.stderr.write("Training ......\n")
    bst = lgb.train(params, train_data, valid_sets=[valid_data])

    sys.stderr.write("Testing ......\n")
    predict = bst.predict(ret_test_data)
    predict = (predict > 0.5).astype(np.int)

    print("MachineIdentifier,HasDetections")
    for m_id, pred in zip(machine_id, predict):
        print("%s,%d" % (m_id, pred))
main()
